<html><head><title>uFMOD reference</title>

<style type='text/css'>body{
font:9pt helvetica}body.navbar{font:10pt helvetica;padding:2px}h1{font:14pt helvetica;font-weight:bold}h2{font:12pt helvetica;font-weight:bold}h3{font:10pt helvetica;font-weight:bold}table{
font:10pt helvetica}th{padding:4px;background:#ccddee;
border-bottom:1px solid #bbccdd}td{padding:4px;background:#ddeeff;
border-bottom:1px solid #ccddee}td.blank{padding:0px;
border:none}td.small{padding:2px;background:#ddeeff;border-bottom:1px solid #ccddee;font:8pt helvetica}td.doctop{padding:10px;background:#ccddee;
border-bottom:1px solid #bbccdd;font:10pt helvetica;vertical-align:text-top;font-weight:bold}td.docleft{padding:10px;background:#ccddee;
border-bottom:1px solid #bbccdd;font:8pt helvetica;vertical-align:text-top;width:10%}td.docright{padding:10px;background:#ddeeff;border-bottom:1px solid #ccddee;font:10pt helvetica;vertical-align:text-top;width:90%}pre{font:10pt courier;background:#eef8ff;
padding:8px}font.token{font-weight:bold}font.syntax{color:#005555
}
div.ref{border:1px solid #000000}div.indent{padding-left:8px}div.syntax{color:#005555;padding:8px}div.entries{
display:none}
</style>

</head><body><center><h1><font color='#808080'>uFMOD.I_uFMOD</font><br>&#956;FMOD (WINMM)</h1></center>
<h2 id=functions>API Reference</h2>
<ul>
<li><a href='#PlayFile'>PlayFile</a>
<li><a href='#PlayMem'>PlayMem</a>
<li><a href='#PlayRes'>PlayRes</a>
<li><a href='#Stop'>Stop</a>
<li><a href='#Pause'>Pause</a>
<li><a href='#Resume'>Resume</a>
<li><a href='#GetStats'>GetStats</a>
<li><a href='#GetRowOrder'>GetRowOrder</a>
<li><a href='#GetTime'>GetTime</a>
<li><a href='#GetTitle'>GetTitle</a>
<li><a href='#SetVolume'>SetVolume</a>
<li><a href='#Jump2Pattern'>Jump2Pattern</a>
</ul>
<table class=doc width=100% cellspacing=3 id=PlayFile>
<tr><td class=doctop colspan=2>static int PlayFile(System::String^ filename,int dwFlags)
<tr><td class=docleft width=1%>Description<td class=docright>Loads the given XM song and starts playing it immediately, unless XM_SUSPENDED is specified. It will stop any currently playing song before loading the new one.
<tr><td class=docleft width=1%>Parameters<td class=docright>
<i>filename</i><br>A string that specifies the name of the file.<br>&nbsp;<br>
<i>dwFlags</i><br>Additional flags, controlling the playback. The following values are defined:<pre>
XM_NOLOOP = 8      An XM track plays repeatedly by default. Specify
                   this flag to play it only once.
XM_SUSPENDED = 16  The XM track is loaded in a suspended state,
                   and will not play until the <a href='#Resume'>Resume</a> method
                   is called. This is useful for preloading a song
                   or testing an XM track for validity.</pre>
Set to zero, if not using any special flags.<br>&nbsp;<br>
<tr><td class=docleft width=1%>Returns<td class=docright>On success, returns a pointer to an open WINMM output device handle. Returns 0 on failure.
<tr><td class=docleft width=1%>Remarks<td class=docright>If no valid song is specified and there is one currently being played, PlayFile just stops playback.
</table><br>
<table class=doc width=100% cellspacing=3 id=PlayMem>
<tr><td class=doctop colspan=2>static int PlayMem(byte* pXM, int length, int dwFlags) // This method requires /unsafe due to pointer usage
<tr><td class=docleft width=1%>Description<td class=docright>Loads the XM song contained in the <i>pXM</i> memory buffer and starts playing it immediately, unless XM_SUSPENDED is specified. It will stop any currently playing song before loading the new one.
<tr><td class=docleft width=1%>Parameters<td class=docright>
<i>pXM</i><br>Points to an image of a song in memory.<br>&nbsp;<br>
<i>length</i><br>Size of the image in bytes.<br>&nbsp;<br>
<i>dwFlags</i><br>Additional flags, controlling the playback. The following values are defined:<pre>
XM_NOLOOP = 8      An XM track plays repeatedly by default. Specify
                   this flag to play it only once.
XM_SUSPENDED = 16  The XM track is loaded in a suspended state,
                   and will not play until the <a href='#Resume'>Resume</a> method
                   is called. This is useful for preloading a song
                   or testing an XM track for validity.</pre>
Set to zero, if not using any special flags.<br>&nbsp;<br>
<tr><td class=docleft width=1%>Returns<td class=docright>On success, returns a pointer to an open WINMM output device handle. Returns 0 on failure.
<tr><td class=docleft width=1%>Remarks<td class=docright>If no valid song is specified and there is one currently being played, PlayMem just stops playback.
</table><br>
<table class=doc width=100% cellspacing=3 id=PlayRes>
<tr><td class=doctop colspan=2>static int PlayRes(int id, int dwFlags)
<tr><td class=docleft width=1%>Description<td class=docright>Loads the given XM resource and starts playing it immediately, unless XM_SUSPENDED is specified. It will stop any currently playing song before loading the new one.
<tr><td class=docleft width=1%>Parameters<td class=docright>
<i>id</i><br>Specifies the ID of the XM resource.<br>&nbsp;<br>
<i>dwFlags</i><br>Additional flags, controlling the playback. The following values are defined:<pre>
XM_NOLOOP = 8      An XM track plays repeatedly by default. Specify
                   this flag to play it only once.
XM_SUSPENDED = 16  The XM track is loaded in a suspended state,
                   and will not play until the <a href='#Resume'>Resume</a> method
                   is called. This is useful for preloading a song
                   or testing an XM track for validity.</pre>
Set to zero, if not using any special flags.<br>&nbsp;<br>
<tr><td class=docleft width=1%>Returns<td class=docright>On success, returns a pointer to an open WINMM output device handle. Returns 0 on failure.
<tr><td class=docleft width=1%>Remarks<td class=docright>The resource type must be RCDATA. The resource is loaded from the current module.<br><br>
If no valid song is specified and there is one currently being played, PlayRes just stops playback.
</table><br>
<table class=doc width=100% cellspacing=3 id=Stop>
<tr><td class=doctop colspan=2>static void Stop()
<tr><td class=docleft width=1%>Description<td class=docright>Stops the currently playing song, if any.
</table><br>
<table class=doc width=100% cellspacing=3 id=Pause>
<tr><td class=doctop colspan=2>static void Pause()
<tr><td class=docleft width=1%>Description<td class=docright>Pauses the currently playing song, if any.
<tr><td class=docleft width=1%>Remarks<td class=docright>While paused you can still control the volume (<a href='#SetVolume'>SetVolume</a>) and the pattern order (<a href='#Jump2Pattern'>Jump2Pattern</a>). The RMS volume coefficients (<a href='#GetStats'>GetStats</a>) will go down to 0 and the progress tracker (<a href='#GetTime'>GetTime</a>) will "freeze" while the song is paused.<br><br>
Pause doesn't perform the request immediately. Instead, it signals to pause when playback reaches next chunk of data, which may take up to about 40ms. This way, Pause performs asynchronously and returns very fast. It is not cumulative. So, calling Pause many times in a row has the same effect as calling it once.<br><br>
If you need synchronous pause/resuming, you can use WINMM waveOutPause/waveOutRestart functions.
</table><br>
<table class=doc width=100% cellspacing=3 id=Resume>
<tr><td class=doctop colspan=2>static void Resume()
<tr><td class=docleft width=1%>Description<td class=docright>Resumes the currently paused song, if any.
<tr><td class=docleft width=1%>Remarks<td class=docright>Resume doesn't perform the request immediately. Instead, it signals to resume when an internal thread gets a time slice, which may take some milliseconds to happen. Usually, calling <b>Sleep(0)</b> immediately after Resume causes it to resume faster. Resume is not cumulative. So, calling it many times in a row has the same effect as calling it once.<br><br>
If you need synchronous pause/resuming, you can use WINMM waveOutPause/waveOutRestart functions.
</table><br>
<table class=doc width=100% cellspacing=3 id=GetStats>
<tr><td class=doctop colspan=2>static uint GetStats()
<tr><td class=docleft width=1%>Description<td class=docright>Returns the current RMS volume coefficients in (L)eft and (R)ight channels.<pre>
low-order word: RMS volume in R channel
hi-order word:  RMS volume in L channel
</pre>Range from 0 (silence) to 0x7FFF (maximum) on each channel.
<tr><td class=docleft width=1%>Remarks<td class=docright>This function is useful for updating a VU meter. It's recommended to rescale the output to log10 (decibels or dB for short), because human ears track volume changes in a dB scale. You may call GetStats() as often as you like, but take in mind that uFMOD updates both channel RMS volumes every 20-40ms, depending on the output sampling rate. So, calling GetStats about 16 times a second whould be quite enough to track volume changes very closely.
</table><br>
<table class=doc width=100% cellspacing=3 id=GetRowOrder>
<tr><td class=doctop colspan=2>static uint GetRowOrder()
<tr><td class=docleft width=1%>Description<td class=docright>Returns the currently playing row and order.<pre>
low-order word: row
hi-order word:  order
</pre>
<tr><td class=docleft width=1%>Remarks<td class=docright>This function is useful for synchronization. uFMOD updates both row and order values every 20-40ms, depending on the output sampling rate. So, calling GetRowOrder about 16 times a second whould be quite enough to track row and order progress very closely.
</table><br>
<table class=doc width=100% cellspacing=3 id=GetTime>
<tr><td class=doctop colspan=2>static uint GetTime()
<tr><td class=docleft width=1%>Description<td class=docright>Returns the time in milliseconds since the song was started.
<tr><td class=docleft width=1%>Remarks<td class=docright>This function is useful for synchronizing purposes. In fact, it is more precise than a regular timer in Win32. Multimedia applications can use GetTime to synchronize GFX to sound, for example. An XM player can use this function to update a progress meter.
</table><br>
<table class=doc width=100% cellspacing=3 id=GetTitle>
<tr><td class=doctop colspan=2>static System::String^ GetTitle()
<tr><td class=docleft width=1%>Description<td class=docright>Returns the current song's title.
<tr><td class=docleft width=1%>Remarks<td class=docright>Not every song has a title, so be prepared to get an empty string.
</table><br>
<table class=doc width=100% cellspacing=3 id=SetVolume>
<tr><td class=doctop colspan=2>static void SetVolume(uint vol)
<tr><td class=docleft width=1%>Description<td class=docright>Sets the global volume. The volume scale is linear.
<tr><td class=docleft width=1%>Parameters<td class=docright>
<i>vol</i><br>New volume. Range: from uFMOD_MIN_VOL = 0 (muting) to uFMOD_MAX_VOL = 25 (maximum volume). Any value above uFMOD_MAX_VOL maps to maximum volume.
<tr><td class=docleft width=1%>Remarks<td class=docright>uFMOD internally converts the given values to a logarithmic scale (dB).<br><br>
Maximum volume is set by default. The volume value is preserved across <a href='#PlayFile'>Play*</a> calls. You can set the desired volume level before actually starting to play a song.<br><br>
You can use WINMM waveOutSetVolume function to control the L and R channels volumes separately. It also has a wider range than SetVolume, sometimes allowing to amplify the sound volume as well, as opposed to SetVolume only being able to attenuate it. The bad things about waveOutSetVolume is that it may produce clicks and it's hardware dependent.
</table><br>
<table class=doc width=100% cellspacing=3 id=Jump2Pattern>
<tr><td class=doctop colspan=2>static void Jump2Pattern(uint pat)
<tr><td class=docleft width=1%>Description<td class=docright>Jumps to the specified pattern index.
<tr><td class=docleft width=1%>Parameters<td class=docright>
<i>pat</i><br>Next zero based pattern index.
<tr><td class=docleft width=1%>Remarks<td class=docright>uFMOD doesn't automatically perform <b>Note Off</b> effects before jumping to the target pattern. In other words, the original pattern will remain in the mixer until it fades out. You can use this feature to your advantage. If you don't like it, just insert leading Note Off commands in all patterns intended to be used as Jump2Pattern targets.<br><br>
if the pattern index lays outside of the bounds of the pattern order table, calling this function jumps to pattern 0, effectively rewinding playback.<br><br>
You can implement Rewind as a call to Jump2Pattern(0).
</table></body></html>